.inc "syscall.inc"
.inc "syscall.lib"
.inc "sysinfo.inc"
.inc "proc.lib"
.inc "sysio.lib"

#default interrupt handlers
.decl func scope() {
INT_SYSCALL:
    ori $at, $zero, 40
    bge $k0, $at, INT_SSC_PROCOP

INT_SSC_NOPROCOP:
    #follows calling convention and uses user space
    addi $sp, $sp, -4
    sw $ra, 0($sp)
    
    #at most 4 instructions for each block
    sll $k0, $k0, 4
    lla $t0, INT_SSC1
    add $k0, $k0, $t0
    jr $k0
INT_SSC1:
    #case 0
    .dup 4 .0
    #case 1: gotoxy
    jal SYS_GOTOXY #sll 0, 0, 0
    j INT_SSCNOPROCEND #sll 0, 0, 0
    #case 2: getxy
    jal SYS_GETXY #sll 0, 0, 0
    j INT_SSCNOPROCEND #sll 0, 0, 0
    #case 3: putc
    jal SYS_PUTC
    j INT_SSCNOPROCEND
    #case 4: getc
    jal SYS_GETC #sll 0, 0, 0
    j INT_SSCNOPROCEND #sll 0, 0, 0
    #case 5-39: reserved
    .dup 140 .0
INT_SSCNOPROCEND:
    lw $ra, 0($sp)
    addi $sp, $sp, 4
    j INT_SSCEND
    
INT_SSC_PROCOP:
    cache_regs
    lli $sp, SYS_STACK_INIT

    addi $k0, $k0, -40
    sll $k0, $k0, 4
    lla $t0, INT_SSC2
    add $k0, $k0, $t0
    jr $k0
INT_SSC2:
    #case 40: fork
    jal SYS_FORK
    j INT_PROCOPEND
    #case 41: exec
    jal SYS_EXEC
    j INT_PROCOPEND
INT_PROCOPEND:
    #if k1==1, there is no return
    bne $k1, $zero, INT_SSCLRESTORE
    SETFRMLB REGS_BUF
    sw $v0, 8($fp)
INT_SSCLRESTORE:
    restore_regs

INT_SSCEND:
    eret
}

.decl func scope() {
INT_TIMER:
    cache_regs
    lli $sp, SYS_STACK_INIT

    jal PROC_SCHEDULE

    restore_regs
    eret
}

.decl func scope() {
GETC_FROM_HW_BUF:
    SETFRM_SYSINFO
    lw $t0, INBUF_START($fp)
    lw $t1, INBUF_END($fp)
    bne $t0, $t1, GFHB_AVL
    #return?
    addi $v0, $zero, -1
    j GFHBEND

GFHB_AVL:
    lw $t1, INBUF_BASE($fp)
    #UGLY FIX!!!!!
    lli $t2, SYS_VIR_ADDR
    add $t1, $t1, $t2
    
    add $t1, $t0, $t1
    lw $v0, 0($t1)
    andi $v0, $v0, 0xff
    addi $t0, $t0, INBUF_UNIT_SIZE
    ori $t1, $zero, INBUF_SIZE
    blt $t0, $t1, GFHB1
    #addi $t0, $t0, -INBUF_SIZE
    and $t0, $zero, $zero
GFHB1:
    sw $t0, INBUF_START($fp)
GFHBEND:
    jr $ra
}

.decl func scope() {
INT_KEYBOARD:
    cache_regs
    lli $sp, SYS_STACK_INIT

INT_KBDAVL:
    jal GETC_FROM_HW_BUF
    blt $v0, $zero, INT_KBDEND
    or $s0, $zero, $v0
    #output to screen
    or $a0, $zero, $s0
    jal SYS_PUTC
    #store to system inbuf
    or $a0, $zero, $s0
    jal SYS_INBUF_PUSHC
    j INT_KBDAVL
INT_KBDEND:
    restore_regs
    eret
}

.decl func scope(main file) {
INT_INIT:
    #interrupt handler for keyboard
    lla $t0, INT_KEYBOARD
    srl $t0, $t0, 2
    lui $t1, 0x0800
    or $t0, $t0, $t1
    swia $t0, 0x80, 0
    lli $t0, 0x40802000 #mtc0 $zero, $4: enable mmu
    swia $t0, 0x84, 0
    #interrupt handler for syscall
    lla $t0, INT_SYSCALL
    srl $t0, $t0, 2
    lui $t1, 0x0800
    or $t0, $t0, $t1
    swia $t0, 0x180, 0
    lli $t0, 0x40802000 #mtc0 $zero, $4: enable mmu
    swia $t0, 0x184, 0
    #interrupt handler for timer
    lla $t0, INT_TIMER
    srl $t0, $t0, 2
    lui $t1, 0x0800
    or $t0, $t0, $t1
    swia $t0, 0x100, 0
    lli $t0, 0x40802000 #mtc0 $zero, $4: enable mmu
    swia $t0, 0x104, 0
    jr $ra
}