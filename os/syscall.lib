.inc "pseudo_inst.inc"
.inc "string.lib"
.inc "sysinfo.inc"
.inc "proc.lib"

.decl func scope(interrupt.lib) {
SYS_GOTOXY: #row, col
    #boundary check
    ori $t0, $zero, SCR_HEIGHT
    bgeu $a0, $t0, SYS_GXYERR
    ori $t0, $zero, SCR_WIDTH * SCR_UNIT_SIZE
    bgeu $a1, $t0, SYS_GXYERR

    #calculate cursor position
    sll $t1, $a0, 6
    sll $t0, $a0, 4
    add $t0, $t0, $t1
    add $t0, $t0, $a1
    #four bytes per unit
    sll $t0, $t0, 2

    #decide real offset
    SETFRM_SYSINFO
    lw $t1, SCR_OFFSET($fp)
    add $t0, $t0, $t1
    ori $t1, $zero, SCR_UNIT_SIZE * SCR_WIDTH * SCR_HEIGHT
    blt $t0, $t1, SYS_GXY1
    addi $t0, $t0, -SCR_UNIT_SIZE * SCR_WIDTH * SCR_HEIGHT

SYS_GXY1:
    sw $t0, CURSOR($fp)
    and $v0, $zero, $zero
    j SYS_GXYEND
    
SYS_GXYERR:
    addi $v0, $zero, -1
SYS_GXYEND:
    jr $ra
}

.decl func scope(interrupt.lib) {
SYS_GETXY:
    SETFRM_SYSINFO
    #calculate reletive cursor
    lw $t0, CURSOR($fp)
    lw $t1, SCR_OFFSET($fp)
    sub $t0, $t0, $t1
    bge $t0, $zero, SYS_GTXY1
    addi $t0, $t0, SCR_UNIT_SIZE * SCR_WIDTH * SCR_HEIGHT
SYS_GTXY1:
    ori $t1, $zero, SCR_UNIT_SIZE * SCR_WIDTH
    divu $t0, $t1
    #row = quotient
    mfhi $v0
    #colomn = remainder / 4
    mflo $v1
    srl $v1, $v1, 2
SYS_GTXYEND:
    jr $ra
}

.decl func {
SYS_CURSORNEXT:
    addi $sp, $sp, -4
    sw $ra, 0($sp)

    SETFRM_SYSINFO
    lw $t1, CURSOR($fp)
    #move cursor
    addi $t1, $t1, SCR_UNIT_SIZE
    ori $t0, $zero, SCR_UNIT_SIZE * SCR_WIDTH * SCR_HEIGHT
    bne $t1, $t0, SYS_CSNXT1
    and $t1, $zero, $zero
SYS_CSNXT1:
    sw $t1, CURSOR($fp)
    
    lw $t2, SCR_OFFSET($fp)
    bne $t1, $t2, SYS_CSNXYEND
    #scroll, t1 is the new starting row and t2 is the old
    addi $t1, $t2, SCR_UNIT_SIZE * SCR_WIDTH
    bne $t1, $t0, SYS_CSNXT2
    and $t1, $zero, $zero
SYS_CSNXT2:
    sw $t1, SCR_OFFSET($fp)
    #clear the last row
    lw $t0, SCR_BASE($fp)
    add $a0, $t0, $t2
    ori $a1, $zero, 0x20
    ori $a2, $zero, 80
    jal MEMWORDSET
SYS_CSNXYEND:
    lw $ra, 0($sp)
    addi $sp, $sp, 4
    jr $ra
}

.decl func scope(interrupt.lib) {
SYS_PUTC: #ch
    addi $sp, $sp, -4
    sw $ra, 0($sp)

    SETFRM_SYSINFO
    lw $t0, SCR_BASE($fp)
    lw $t1, CURSOR($fp)

    #write to disp mem
    add $t0, $t0, $t1
    #UGLY FIX!!!!!!!
    lli $t1, 0x01800000
    add $t0, $t0, $t1
    
    sw $a0, 0($t0)
    jal SYS_CURSORNEXT

    lw $ra, 0($sp)
    addi $sp, $sp, 4
    jr $ra
}

.decl func scope(interrupt.lib, io.lib, main file) {
SYS_GETC:
    SETFRM_SYSINFO
    lw $t0, INBUF_START($fp)
    lw $t1, INBUF_END($fp)
    bne $t0, $t1, SYS_GTCAVL
    #return?
    addi $v0, $zero, -1
    j SYS_GTCEND

    #block?
    #j SYS_GETC

SYS_GTCAVL:
    lw $t1, INBUF_BASE($fp)
    add $t1, $t0, $t1
    lw $v0, 0($t1)
    andi $v0, $v0, 0xff
    addi $t0, $t0, INBUF_UNIT_SIZE
    ori $t1, $zero, INBUF_SIZE
    blt $t0, $t1, SYS_GTC1
    #addi $t0, $t0, -INBUF_SIZE
    and $t0, $zero, $zero
SYS_GTC1:
    sw $t0, INBUF_START($fp)
SYS_GTCEND:
    jr $ra
}

.decl func scope() {
FIND_UNUSED_GDT_ITEM:   #gdt_vir_addr, returns first unused item addr
    ori $t0, $zero, GDT_SIZE                    #t0 reserved as GDT_SIZE
FUGI1:
    lw $t1, 12($a0)                             #load the valid flag
    beq $t1, $zero, FUGIEND                    #unused gdt item found
    addi $a0, $a0, GDT_ITEM_SIZE
    beq $a0, $t2, FUGIERR                    #no unused gdt item found
    j FUGI1
FUGIERR:
    j FUGIERR                                #don't know how to handle here, apply a forever loop
FUGIEND:
    or $v0, $zero, $a0
    jr $ra
}

.decl func scope(interrupt.lib) {
SYS_FORK:
    cache_regs

    addi $sp, $sp, -8
    sw $ra, 0($sp)
    sw $s0, 4($sp)

    SETFRMLB PROC
    
    lw $s0, MAX_PROC_OFF($fp)           #s0 reserved as new PROC_ID

    #change MAX_PROC without overflow check
    addi $t0, $s0, 1
    sw $t0, MAX_PROC_OFF($fp)

    addi $t3, $fp, PROC_INFO_OFF        #t3 reserved as addr of PROC_INFO
    #proc_id * 256w
    sll $t2, $t0, PROC_INFO_LOG_SIZE
    add $t1, $t3, $t2
    #init proc state
    sw $zero, PROC_STATE_OFF_PER_PROC($t1)      #state = 0

    #copy current process to the new one
    #find a place in gdt to do memory mapping
    sll $a0, $s0, PROC_INFO_LOG_SIZE
    add $a0, $a0, $t3
    jal FIND_UNUSED_GDT_ITEM
    or $s0, $v0, $v0
    #map the userspace of the new process to 8M - 16M here
    sll $t0, $s0, PROC_USRSPACE_LOG_SIZE
    sw $t0, 0($s0)                              #physical address
    lli $t1, PROC_USRSPACE_SIZE                 #8M
    sw $t1, 4($s0)                              #virtual address
    sw $t1, 8($s0)                              #size
    ori $t0, $zero, 1
    sw $t0, 12($s0)                             #validate
    #copy code and static data !!! assumed less than 2M here
    or $a0, $zero, $t1                          #8M
    and $a1, $zero, $zero                       #0M
    #lli $a2, 0x80000                            #(2M / 4) words
    lli $a2, 0x8000                             #(128K / 4) words
    jal MEMWORDCPY
    #copy stack data
    #load sp from cached regs
    SETFRMLB REGS_BUF
    lw $t0, (29 * 4)($fp)
    lli $a2, PROC_USRSPACE_SIZE
    add $a0, $a2, $t0                   #we use user stack in syscall
    or $a1, $zero, $t0
    #calc stack size in words
    sub $a2, $a2, $t0
    srl $a2, $a2, 2
    jal MEMWORDCPY
    #copy registers
    and $v0, $zero, $zero               #set return value of fork for child process
    or $a0, $zero, $s0
    jal FLUSH_REGS
    or $v0, $zero, $s0                  #set return value of fork for father process
    #restore gdt
    sw $zero, 12($s0)

#SYS_FRKEND:
    lw $ra, 0($sp)
    lw $s0, 4($sp)
    addi $sp, $sp, 8
    jr $ra
}

.decl func scope(interrupt.lib) {
SYS_EXEC:
    #set epc to zero
    SETFRMLB PROC
    #UGLY FIX!!!! should load CUR_PROC_OFF here instead of MAX_PROC_OFF
    lw $t0, MAX_PROC_OFF($fp)
    SETFRM_SYSINFO
    sll $t2, $t0, 24
    sw $t2, HDD_SPMO($fp)
    sll $a0, $a0, 12    # a0 * 0x1000
    sw $a0, HDD_SSN($fp)
    ori $t2, $zero, 0x1000
    sw $t2, HDD_MAX_TSIZE($fp)
    ori $t2, $zero, 1
    sw $t2, HDD_ENABLE($fp)

    jr $ra
}
