.inc "string.lib"

.decl func local {
SYS_GOTOXY: #row, col
    #boundary check
    ori $t0, $zero, SCR_HEIGHT
    bgeu $a0, $t0, SYS_GXYERR
    ori $t0, $zero, SCR_WIDTH
    bgeu $a1, $t0, SYS_GXYERR

    #calculate cursor position
    sll $t1, $a0, 6
    sll $t0, $a0, 4
    add $t0, $t0, $t1
    add $t0, $t0, $a1
    #four bytes per unit
    sll $t0, $t0, 2

    #decide real offset
    SETFRM_SYSINFO
    lw $t1, SCR_OFFSET($fp)
    add $t0, $t0, $t1
    ori $t1, $zero, 4 * SCR_WIDTH * SCR_HEIGHT
    blt $t0, $t1, SYS_GXY1
    addi $t0, $t0, -4 * SCR_WIDTH * SCR_HEIGHT

SYS_GXY1:
    sw $t0, CURSOR($fp)
    and $v0, $zero, $zero
    j SYS_GXYEND
    
SYS_GXYERR:
    addi $v0, $zero, -1
SYS_GXYEND:
    jr $ra
}

.decl func local {
SYS_CURSORNEXT:
    addi $sp, $sp, -4
    sw $ra, 0($sp)

    SETFRM_SYSINFO
    lw $t1, CURSOR($fp)
    #move cursor
    addi $t1, $t1, 4
    ori $t0, $zero, 4 * SCR_WIDTH * SCR_HEIGHT
    blt $t1, $t0, SYS_CSNXT1
    addi $t1, $t1, -4 * SCR_WIDTH * SCR_HEIGHT
SYS_CSNXT1:
    sw $t1, CURSOR($fp)

    lw $t2, SCR_OFFSET($fp)
    bne $t1, $t2, SYS_CSNXT3

    #scroll, t1 is the new starting row and t2 is the old
    addi $t1, $t2, 4 * SCR_WIDTH
    blt $t1, $t0, SYS_CSNXT2
    addi $t1, $t1, -4 * SCR_WIDTH * SCR_HEIGHT
SYS_CSNXT2:
    sw $t1, SCR_OFFSET($fp)
    #clear the last row
    lw $t0, SCR_BASE($fp)
    add $a0, $t0, $t2
    ori $a1, $zero, 0x20
    ori $a2, $zero, 80
    jal MEMWORDSET

SYS_CSNXT3:
    lw $ra, 0($sp)
    addi $sp, $sp, 4
    jr $ra
}

.decl func local {
SYS_PUTC: #ch
    addi $sp, $sp, -4
    sw $ra, 0($sp)

    SETFRM_SYSINFO
    lw $t0, SCR_BASE($fp)
    lw $t1, CURSOR($fp)

    #write to disp mem
    add $t0, $t0, $t1
    sw $a0, 0($t0)
    jal SYS_CURSORNEXT

    lw $ra, 0($sp)
    addi $sp, $sp, 4
    jr $ra
}

.decl func local {
SYS_GETC:
    SETFRM_SYSINFO
    lw $t0, INBUF_START($fp)
    lw $t1, INBUF_END($fp)
    bne $t0, $t1, SYS_GTCAVL
    #return?
    addi $v0, $zero, -1
    j SYS_GTCEND

    #block?
    #j SYS_GETC

SYS_GTCAVL:
    lw $t1, INBUF_BASE($fp)
    add $t1, $t0, $t1
    lw $v0, 0($t1)
    andi $v0, $v0, 0xff
    addi $t0, $t0, 4
    ori $t1, $zero, INBUF_SIZE
    blt $t0, $t1, SYS_GTC1
    addi $t0, $t0, -INBUF_SIZE

SYS_GTC1:
    sw $t0, INBUF_START($fp)
SYS_GTCEND:
    jr $ra
}

.decl func {
SYS_SYSCALL:
    addi $sp, $sp, -4
    sw $ra, 0($sp)
    #at most 2 instructions for each block
    sll $k0, $k0, 3
    addi $k0, $k0, 4 + LABEL
LABEL:
    jr $k0
    #case 0
    .dup 2 .0
    #case 1: gotoxy
    jal SYS_GOTOXY
    j SYSCLEND
    #case 2: putc
    jal SYS_PUTC
    j SYSCLEND
    #case 3: getc
    jal SYS_GETC
    j SYSCLEND
SYSCLEND:
    lw $ra, 0($sp)
    addi $sp, $sp, 4
    jr $ra
}
